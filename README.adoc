= Editing Lisp and Scheme files in Neovim

Neoscmindent is a Neovim native-Lua implementation of an indenting
function for Scheme, Lisp, and similar languages.

== Installation

If you just want the indenter installed with minimum fuss,
use the enclosed script `install.sh`.

First,
`git clone` this repository. This will create a local directory
called `neoscmindent`. `cd` to it, and type

   ./install.sh

That's it.

Go to the section _Alternative installation approaches_ if you
need to.

== Indentation strategy

Lisp code is essentially recursive lists of ultimately atoms. We
call these code constituents _forms_. A form, if it is a
non-empty list, has a head subform and zero or more argument
subforms. Thus:

  (head-subform arg-subform-1 arg-subform-2 ...)

Indenting Lisp code adds or removes spaces before each line so
that the code has a quickly readable structure. Indenting does
not change the content of a code line, and therefore, cannot add
or remove lines. Here are the default rules for how Neoscmindent
goes about indenting Lisp code:

1: If the head subform is an atom and is followed by at least one
other subform on its own line, then all subsequent lines in the
form are indented to line up under the first argument subform.
E.g.,

  (some-function-1 arg1
                   arg2
                   ...)

2: If the head subform is an atom and is on a line by itself,
then its subsequent lines are indented one column past the
beginning of the head atom. E.g.,

  (some-function-2
    arg1
    arg2
    ...)

3: If the head subform is a list, then its subsequent lines are
indented to line up under the head subform. It does not matter
whether there are argument subforms on the same line as the head
form or not. E.g.,

  ((some-function-3 s-arg1 ...)
   arg1
   arg2
   ...)

4: If the head form is a literal (a non-symbolic atom, such as
a number), then its subsequent lines are indented to line up
directly under the head literal. It does not matter whether there
are argument subforms on the same line as the head form or not. E.g.,

  (1 2 3
   4 5 6)

  '(alpha
    beta
    gamma)

(In the last example, the list is quoted, so its elements are
considered literal, even though in general `alpha` would not be a
literal.)

If this were all there is to it, it would make for rather boring
indentation. So there is one exception thrown into the mix, for
when the head subform is a symbol that we want to treat as a
special keyword.  A keyword is a symbol that has a Lisp Indent
Number, or LIN, associated with it. The section on customization
tells you how to set LINs. Let us call a keyword an N-keyword
if it has a LIN of N.

5: If a form whose head is an N-keyword is split across
lines, and if its i'th subform starts a line, then that
subform's indentation depends on the value of i relative to
N.

5a: If i ≤ N, then the i'th subform is indented 3 columns
past the beginning of the head keyword.

5b: If i > N, then the i'th subform is indented just one
column past the beginning of the head keyword.

Examples:

  (keyword-3 arg1
      arg2
      arg3
    arg4
    ...)

  (keyword-3 arg1 arg2 arg3
    arg4
    ...)

== Customization

Neoscmindent uses keyword info from `~/.lispwords.lua`. Here is
an example `.lispwords.lua`: It's simply a Lua file that
returns a Lua table associating keywords with their proposed
LINs:

  return {
    ['call-with-input-file'] = 1,
    ['case'] = 1,
    ['do'] = 2,
    ['do*'] = 2,
    ['fluid-let'] = 1,
    ['lambda'] = 1,
    ['let'] = 1,
    ['let*'] = 1,
    ['letrec'] = 1,
    ['let-values'] = 1,
    ['unless'] = 1,
    ['when'] = 1,
  }

Neoscmindent also checks for option `'lispwords'` (aka `'lw'`)
for the LIN of a keyword that it can't find in `.lispwords.lua`.
Such keywords are assumed to have LIN 0.

If a keyword is neither in `'.lispwords.lua'` nor in `'lispwords'`,
but starts with `def`, its LIN is taken to be 0.
(This is because Lispers tend to create ad hoc definer keywords,
whether procedure or macro, whose names start with `def`, and
which they expect to not indent their subforms
excessively, as rule 1 would require.)

All other keywords have LIN −1. These keywords follow the rules
1 and 2 above. You shouldn't need to explicitly set a LIN of −1, unless
the keyword is already in `'lispwords'` (hence LIN 0), and you
need to force it to behave like an ordinary symbol.

If you ever want a keyword to behave like a literal (rule 4), then set
its LIN to −2.

== A note on `if`

The keyword `if` is in `'lispwords'`, so by default it has LIN 0.
`if` typically has 2 or 3 subforms. (In Common Lisp and some older
Schemes it has 2 to 3; in modern Schemes exactly 3; in Emacs Lisp
2 to ∞.)
Its first subform -- the test subform
-- is almost always on the same line as the `if`. And since the
LIN is 0, every subform under it is aligned 1 column to the right
of the `if`, like so:

  (if test
    then
    else)

Some people like it. Many don't: Here are three alternative LINs
for `if`:

1: Set LIN to −1.

  (if test
      then
      else)

Since −1 is the default LIN for a keyword not in `'lispwords'`,
you could either remove `if` from
`'lispwords'` (global or local to your filetype), or set its
LIN explicitly to −1 in `~/.lispwords.lua`.

(Racket house style requires LIN −1, so if you're OK with Racket,
you can skip the rest of this section.)

2: Set LIN to 2.

  (if test
      then
    else)

This has the advantage of distinguishing the then- and else-
clauses.

3: Set LIN to 3. This indents both the
then- and else-clause to be 3 columns to the right of `if`. It
so happens `if` and its post-token space take up 3 columns,
so you get the same result as LIN −1. Well, almost.

In the rare case you break
the line before the then-clause, LIN −1 gives you

  (if
    test
    then
    else)

whereas, with LIN 3:

  (if
      test
      then
      else)

Which seems better? Another difference shows up if you have more than one
else-clause (this is allowed in Emacs Lisp).  With LIN −1:

  (if test
      then
      else1
      else2
      ...)

With LIN 3:

  (if test
      then
      else1
    else2
    ...)

which seems objectively bad. LIN 2 would have:

  (if test
      then
    else1
    else2
    ...)

which seems better because it keeps the else-subforms together
but distinct from the (single) then-form. In sum, go with LIN −1
if you want the then- and else-forms aligned; or with 2 if you
want them distinguished.

== Alternative installation approaches

While the quick-install works for most people, if you already
have an extensive Lisp editing setup, you may wish to incorporate the
essentials of Neoscmindent in a more flexible way.

Let's deconstruct the quick install: It puts the `neoscmindent`
repo under a `pack` subdirectory somewhere in your `'runtimepath'`
(aka `'rtp'`) or `'packpath'` (aka `'pp'`).  (See `:help
packages.)

An explicit install lets you pick the
`'pack'` subdirectory. Assuming `~/.config/nvim` is in your
`'runtimepath'`, a suitable `'pack'` directory is
`~/.config/nvim/pack`.

Ensure a relevant subdirectory exists to receive `neoscminent`:

  mkdir -p ~/.config/nvim/pack/3rdpartyplugins/start

Go there and clone this repo:

  cd ~/.config/nvim/pack/3rdpartyplugins/start
  git clone https://github.com/ds26gte/neoscmindent

(You don't really need a plugin manager for this, but I expect
that would work too, not that I've tried.)

If you don't want to deal with packages at all, you can individually
copy just the three essential files from the repo into your Neovim
config area. The three files are:

  autoload/scmindent.vim
  lua/scmindent.lua
  after/indent/lisp.vim

Again, unless you're doing something atypical, your
`'runtimepath`' includes the directory `~/.config/nvim`. Copy the
above three files to the `autoload`, `lua`, and `after/indent`
subdirectories respectively. First, ensure that these directories
exist:

  mkdir -p ~/.config/nvim/autoload
  mkdir -p ~/.config/nvim/lua
  mkdir -p ~/.config/nvim/after/indent

Then, after `cd`ing to the repo directory, copy the three files
over:

  cp -p autoload/scmindent.vim ~/.config/nvim/autoload
  cp -p lua/scmindent.lua ~/.config/nvim/lua
  cp -p after/indent/lisp.vim ~/.config/nvim/after/indent

The `after/indent/lisp.vim` adds to the default indent plugin for
Scheme and Lisp files some canned stuff that will let
Neoscmindent do its thing. You may already have such a file, or
wish to roll your own. In that case, do not copy this file over,
or if you installed the entire repo under a `'pack'` directory,
delete this file.

If you want to create or modify your own `after/indent/lisp.vim`, make sure that it
sets the `'indentexpr'` (aka `'inde'`) option and _unsets_ the `'lisp'` and
`'equalprg'` (`'ep'`) options:

  setl nolisp
  setl equalprg=
  setl indentexpr=scmindent#GetScmIndent(v:lnum)

If you're wondering why you don't need an
`after/indent/scheme.vim`, this is because Vim's
`indent/scheme.vim` takes care to load any and all
`indent/lisp.vim` files that are present. For other Lisp-like
files with a different filetype, you would add these lines to
their specific `after/indent` file.

You can avoid an `after` file by explicitly assigning these
options via a filetype autocommand, either in your `init.vim`
or in a regular plugin file in your `plugin` directory:

  autocmd filetype scheme,lisp
     \ setl nolisp ep= inde=scmindent#GetScmIndent(v:lnum)

Again, add other filetypes to the command above as needed.

=== A note on `'lisp'` and `'equalprg'`

`'lisp'` and `'equalprg'` need to be unset because they both
override `'indentexpr'` (and `'lisp'` overrides `'equalprg'`).
They allow alternative, less featureful ways to indent Lisp in
the vi family of editors.

Typically, the options `'lisp'`, `'autoindent'` (aka `'ai'`), and
`'showmatch'` (`'sm'`) are set together, but except in the improved vi
clones Vim and Neovim, this approach fails in at least two
respects:

1. escaped parentheses and double-quotes are not treated
correctly; and

2. all head-words are treated identically.

Even the redoubtable Vim, which has improved its Lisp editing
support over the years, and provides the `'lispwords'` option to
identify keywords,
continues to fail in
https://github.com/ds26gte/neoscmindent/blob/master/vim-indent-error.lisp[strange
ways]. Neovim inherits this legacy.

Fortunately, both vi and Vim let you delegate the responsibility
for indenting such code to an external filter program of your
choosing via the `'equalprog'`.  Indeed, you can use the
`lua/scmindent.lua` file in this repo as one such filter, viz.,

  setl equalprg=scmindent.lua

This assumes you have placed `scmindent.lua` in your `PATH`, and
that you have Lua on your system. Neoscmindent's parent software,
https://github.com/ds26gte/scmindent, provides more such filters,
in different languages.

While this works, the
experience is clunkier than using `'indentexpr'`, because
autoindentation will be according the `'autoindent'` option,
which isn't very Lispy. To get your code correctly indented, you
have to explicitly type `=` in normal mode every so often. Still,
if you are OK with this extra effort, it will DTRT. It is also
the only way of using `scmindent.lua` if you're not using Neovim.

The approach using `'indentexpr'` offers the least friction. It
does require that you use Neovim, not Vim, let alone any other vi.

// Last modified 2019-11-10
