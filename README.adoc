= Neoscmindent -- indent Scheme and Lisp files in Neovim

This is a Neovim native-Lua implementation of an indenting
function for Scheme, Lisp, and similar languages.

== Installation

This package contains the files

  autoload/neoscmindent.vim
  lua/neoscmindent.lua
  after/indent/lisp.vim

Copy them to the `autoload`, `lua`, and `after/indent` subdirectories respectively,
somewhere in your Neovim `'runtimepath'` (aka `'rtp'`). Unless
you're doing something atypical, your `'rtp'` includes
the directory `~/.config/nvim`, so you could do:

   # ensure that the relevant subdirectories in your rtp exist
   mkdir -p ~/.config/nvim/autoload
   mkdir -p ~/.config/nvim/lua
   mkdir -p ~/.config/nvim/after/indent

   # go to the directory created by this repo
   cd <this-repo-directory>

   # copy the files from the repo to the appropriate places in rtp
   cp -p autoload/neoscmindent.vim ~/.config/nvim/autoload
   cp -p lua/neoscmindent.lua ~/.config/nvim/lua
   cp -p after/indent/lisp.vim ~/.config/nvim/after/indent

Alternatively, clone this repo inside the `pack` subdirectory
somewhere in your `'rtp'`, using the path suggested in `:help
packages`. E.g., again assuming
`~/.config/nvim` is in your `'rtp'`, you could do

  # ensure that the relevant pack subdirectory exists
  mkdir -p ~/.config/nvim/pack/neoscmindent/start

  # go there
  cd ~/.config/nvim/pack/neoscmindent/start

  # clone this repo there
  git clone https://github.com/ds26gte/neoscmindent

Either approoach is easy enough, you don't really need a
3rd-party plugin manager, but I expect that would work too, not
that I've tried.

The `after/indent/lisp.vim` is just for convenience. You may want
to trigger the indenter in your own way, especially if you
already have a familiar setup for your Scheme and Lisp (or other
Lisp-y) files. Whatever you do, you have to make sure that the
local option `'indentexpr'` (aka `'inde'`) is set for the files
that you want indented by Neoscmindent, i.e.,

  setl inde=neoscmindent#GetScmIndent(v:lnum)

You also need to ensure that the options `'lisp'` and
`'equalprg'` (aka `'ep'`) are _not_ set, so `'inde'` can come
into its own.

(`'lisp'` is Vim's own attempt at indenting Lisp. It's less
featureful than Neoscmindent, and also occasionally buggy.)

(`'equalprg'` is used to call an external-program indenter, e.g.,
the kinds provided in Neoscmindent's parent software,
https://github.com/ds26gte/scmindent. If you're using Neovim,
then Neoscmindent is the better choice as it runs natively in
Neovim without requiring an external program in a language that
you may not have installed. If you're using Vim, well, Scmindent
is your only choice.)

(If you're wondering why the repo doesn't provide an
`after/indent/scheme.vim`, this is because Vim's
`indent/scheme.vim` takes care of loading any and all
`indent/lisp.vim` filess that are present.)

== Indentation strategy

Lisp code is essentially recursive lists of ultimately atoms. We
call these code constituents _forms_. A form, if it is a
non-empty list, has a head subform and zero or more argument
subforms. Thus:

  (head-subform arg-subform-1 arg-subform-2 ...)

Indenting Lisp code adds or removes spaces before each line so
that the code has a quickly readable structure. Indenting does
not change the content of a code line, and therefore, cannot add
or remove lines. Here are the default rules for how Neoscmindent
goes about indenting Lisp code:

1: If the head subform is an atom and is followed by at least one
other subform on its own line, then all subsequent lines in the
form are indented to line up under the first argument subform.
E.g.,

  (some-function-1 arg1
                   arg2
                   ...)

2: If the head subform is an atom and is on a line by itself,
then its subsequent lines are indented one column past the
beginning of the head atom. E.g.,

  (some-function-2
    arg1
    arg2
    ...)

3: If the head subform is a list, then its subsequent lines are
indented to line up under the head subform. It does not matter
whether there are argument subforms on the same line as the head
form or not. E.g.,

  ((some-function-3 s-arg1 ...)
   arg1
   arg2
   ...)

4: If the head form is a literal (a non-symbolic atom, such as
a number), then its subsequent lines are indented to line up
directly under the head literal. It does not matter whether there
are argument subforms on the same line as the head form or not. E.g.,

  (1 2 3
   4 5 6)

  '(alpha
    beta
    gamma)

(In the last example, the list is quoted, so its elements are
considered literal, even though in general `alpha` would not be a
literal.)

If this were all there is to it, it would make for rather boring
indentation. So there is one exception thrown into the mix, for
when the head subform is a symbol that we want to treat as a
special keyword.  A keyword is a symbol that has a Lisp Indent
Number, or LIN, associated with it. The section on customization
tells you how to set LINs. Let us call a keyword an N-keyword
if it has a LIN of N.

5: If a form whose head is an N-keyword is split across
lines, and if its i'th subform starts a line, then that
subform's indentation depends on the value of i relative to
N.

5a: If i ≤ N, then the i'th subform is indented 3 columns
past the beginning of the head keyword.

5b: If i > N, then the i'th subform is indented just one
column past the beginning of the head keyword.

Examples:

  (keyword-3 arg1
      arg2
      arg3
    arg4
    ...)

  (keyword-3 arg1 arg2 arg3
    arg4
    ...)

== Customization

Neoscmindent uses keyword info from `~/.lispwords.lua`. Here is
an example `.lispwords.lua`: It's simply a Lua file that
returns a Lua table associating keywords with their proposed
LINs:

  return {
    ['call-with-input-file'] = 1,
    ['case'] = 1,
    ['do'] = 2,
    ['do*'] = 2,
    ['fluid-let'] = 1,
    ['lambda'] = 1,
    ['let'] = 1,
    ['let*'] = 1,
    ['letrec'] = 1,
    ['let-values'] = 1,
    ['unless'] = 1,
    ['when'] = 1,
  }

Neoscmindent also checks for option `'lispwords'` (aka `'lw'`)
for the LIN of a keyword that it can't find in
`.lispwords.lua`. Such keywords are assumed to have LIN 0.
(Please note that Neoscmindent can only peer at the global, not
local, version of `'lispwords'`.)

If a keyword is neither in `'.lispwords'` nor in `'lispwords'`,
but starts with `def`, its LIN is taken to be 0.
(This is because Lispers tend to create ad hoc definer keywords,
whether procedure or macro, whose names start with `def`, and
which they expect to not indent their subforms
excessively, as rule 1 would require.)

All other keywords have LIN −1. These keywords follow the rules
1 and 2 above. You shouldn't need to explicitly set a LIN of −1, unless
the keyword is already in `'lispwords'` (hence LIN 0), and you
need to force it to behave like an ordinary symbol.

If you ever want a keyword to behave like a literal (rule 4), then set
its LIN to −2.
